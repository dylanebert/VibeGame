# VibeGame Engine

3D game engine with declarative XML and ECS. Auto-creates player, camera, lighting - just add ground.

## Quick Start

```html
<script src="https://cdn.jsdelivr.net/npm/vibegame@latest/dist/cdn/vibegame.standalone.iife.js"></script>
<world canvas="#game-canvas" sky="#87ceeb">
  <static-part pos="0 -0.5 0" shape="box" size="20 1 20" color="#90ee90"></static-part>
</world>
<canvas id="game-canvas"></canvas>
<script>GAME.run();</script>
```

Auto-created: Player (WASD+jump), orbital camera (mouse), lighting with shadows.

## Critical Rules

⚠️ **Physics overrides transform**: Use `pos` on physics entities, not transform position.
⚠️ **Ground required**: Player falls forever without `<static-part>` ground.
⚠️ **Bare attributes = defaults**: `<entity transform>` includes transform with defaults.

## Core Concepts

### ECS Architecture
- **Entities**: IDs only (numbers)
- **Components**: Data (position, health)
- **Systems**: Logic processing entities with specific components
- **Queries**: Find entities by components

### Update Phases
1. **SetupBatch**: Input, frame init (once/frame)
2. **FixedBatch**: Physics at 50Hz (0-N times/frame)
3. **SimulationBatch**: Game logic
4. **DrawBatch**: Rendering, interpolation

## Physics Recipes

```xml
<!-- Static: immovable (grounds, walls) -->
<static-part pos="0 -0.5 0" shape="box" size="20 1 20" color="#808080"></static-part>

<!-- Dynamic: gravity-affected (balls, crates) -->
<dynamic-part pos="0 5 0" shape="sphere" size="1" color="#ff0000"></dynamic-part>

<!-- Kinematic: script-controlled (platforms, doors) -->
<kinematic-part name="lift" pos="0 2 0" shape="box" size="3 0.5 3"></kinematic-part>
<tween target="lift" attr="body.pos-y" from="2" to="5" duration="3" easing="sine-in-out"></tween>
```

### Position Pitfall
```xml
<!-- ❌ WRONG: transform position ignored with physics -->
<entity transform="pos: 0 5 0" body collider></entity>

<!-- ✅ CORRECT: pos shorthand applies to body -->
<dynamic-part pos="0 5 0" shape="sphere"></dynamic-part>
```

## Recipe Reference

| Recipe | Purpose | Key Attributes |
|--------|---------|---------------|
| `<static-part>` | Immovable | `pos`, `shape`, `size`, `color` |
| `<dynamic-part>` | Falls with gravity | `pos`, `shape`, `size`, `color`, `mass` |
| `<kinematic-part>` | Script-controlled | `pos`, `shape`, `size`, `color` |
| `<renderer>` | Visual only | `pos`, `shape`, `size`, `color` |
| `<player>` | Character | `pos`, `speed`, `jump-height` |
| `<tween>` | Animation | `target`, `attr`, `to`, `duration`, `easing` |
| `<sequence>` | Animation group | `name`, `autoplay` |
| `<pause>` | Sequence timing | `duration` |

**Shapes**: `box`, `sphere`
**Size**: `size="w h d"` or broadcast `size="2"` → `2 2 2`

## Tweening

One-shot animations that auto-destroy. Reference entities by `name`.

```xml
<kinematic-part name="door" pos="0 0 0" shape="box" size="2 4 0.2"></kinematic-part>
<tween target="door" attr="body.pos-y" to="3" duration="2" easing="sine-out"></tween>
```

### Shorthands
| Shorthand | Expands To |
|-----------|------------|
| `at` | transform.posX/Y/Z |
| `scale` | transform.scaleX/Y/Z |
| `rotation` | body.eulerX/Y/Z (or transform) |

### Easing
`linear`, `sine-in/out/in-out`, `quad-*`, `cubic-*`, `back-*`, `elastic-*`, `bounce-*`

## Sequences

Orchestrate tweens with timing. Tweens before `<pause>` run in parallel.

```xml
<sequence name="bounce">
  <tween target="cube" attr="scale" to="1.3 1.3 1.3" duration="0.15" easing="back-out"></tween>
  <pause duration="0.1"></pause>
  <tween target="cube" attr="scale" to="1 1 1" duration="0.15"></tween>
</sequence>
```

```typescript
import { playSequence, resetSequence } from 'vibegame/tweening';
const seq = state.getEntityByName('bounce');
resetSequence(state, seq);
playSequence(state, seq);
```

## Optional Plugins

### Post-Processing
```typescript
import { PostprocessingPlugin } from 'vibegame/postprocessing';
GAME.withPlugin(PostprocessingPlugin).run();
```
```xml
<orbit-camera bloom="intensity: 2" tonemapping="mode: aces-filmic"></orbit-camera>
```

### 3D Text
```typescript
import { TextPlugin } from 'vibegame/text';
GAME.withPlugin(TextPlugin).run();
```
```xml
<word text="Hello" font-size="2" color="#ff0000"></word>
<paragraph gap="0.3"><word text="Hello"></word><word text="World"></word></paragraph>
```

### Vector Lines
```typescript
import { LinePlugin } from 'vibegame/line';
GAME.withPlugin(LinePlugin).run();
```
```xml
<entity transform line="offset: 3 2 0; color: 0xff0000; arrow-end: 1"></entity>
```

## Custom Plugin Pattern

```typescript
const Health = GAME.defineComponent({ current: GAME.Types.f32, max: GAME.Types.f32 });
const healthQuery = GAME.defineQuery([Health]);

const HealthSystem: GAME.System = {
  group: 'simulation',
  update: (state) => {
    for (const entity of healthQuery(state.world)) {
      if (Health.current[entity] < Health.max[entity])
        Health.current[entity] += 5 * state.time.deltaTime;
    }
  }
};

const HealthPlugin: GAME.Plugin = {
  components: { Health },
  systems: [HealthSystem],
  config: { defaults: { health: { current: 100, max: 100 } } }
};

GAME.withPlugin(HealthPlugin).run();
```

## State API

```typescript
// Entity management
state.createEntity(): number
state.destroyEntity(entity)
state.getEntityByName(name): number | null

// Components
state.addComponent(entity, Component, data?)
state.removeComponent(entity, Component)
state.hasComponent(entity, Component): boolean

// Time
state.time.delta    // Frame time (seconds)
state.time.elapsed  // Total time
state.time.fixed    // Fixed timestep (1/50)
```

## Headless CLI

For testing without browser/WebGL:

```typescript
import { createHeadlessState, parseWorldXml, getEntityNames, createSnapshot, toJSON } from 'vibegame/cli';

const state = createHeadlessState({ plugins: DefaultPlugins });
await state.initializePlugins();
parseWorldXml(state, xmlContent);

state.step(1/60);
console.log(toJSON(createSnapshot(state, { entities: getEntityNames(state) })));
```

Screen projection is included by default, returning `{ x, y, z, visible }` for each entity (1920x1080 viewport). Use `project: false` to disable.

## Common Mistakes

```xml
<!-- ❌ No ground → player falls forever -->
<world canvas="#game-canvas">
  <dynamic-part pos="0 5 0" shape="sphere"></dynamic-part>
</world>

<!-- ❌ Dynamic platform falls with gravity -->
<dynamic-part name="platform" pos="0 3 0"></dynamic-part>
<tween target="platform" attr="body.pos-x" from="-5" to="5"></tween>

<!-- ✅ Use kinematic for controlled movement -->
<kinematic-part name="platform" pos="0 3 0"></kinematic-part>
```

## Plugin Reference

### Core

Math utilities for interpolation and 3D transformations.

### Functions

#### lerp(a, b, t): number
Linear interpolation

#### slerp(fromX, fromY, fromZ, fromW, toX, toY, toZ, toW, t): Quaternion
Quaternion spherical interpolation

#### Examples

## Usage Note

Math utilities are used internally by systems like tweening and transforms. For animating properties, use the Tween system instead of directly calling interpolation functions. For transformations, use the Transform component's euler angles which are automatically converted to quaternions by the system.

### Animation

Procedural character animation with body parts responding to movement states.

### Components

**AnimatedCharacter**
- headEntity, torsoEntity, leftArm/rightArm/leftLeg/rightLegEntity: eid
- phase: f32 (0-1) - Walk cycle
- animationState: ui8 - 0=IDLE, 1=WALKING, 2=JUMPING, 3=FALLING, 4=LANDING

#### Examples

```xml
<entity animated-character character-controller transform="pos: 0 2 0"></entity>
```

```typescript
// Check animation state
if (AnimatedCharacter.animationState[entity] === 2) { /* jumping */ }
```

### Cli

Headless state creation, XML parsing, text measurement, snapshot, and query utilities for Node.js/Bun. Enables AI testing and video creation without browser/WebGL.

### Headless State

- `createHeadlessState(options)` - Creates State with `headless=true`
- `parseWorldXml(state, xml, options?)` - Parses XML string, creates entities
- `loadWorldFromFile(state, path)` - Loads XML from file

ParseOptions:
- `ignoreUnknownAttributes?: string[]` - Skip validation for specified attributes

### Text Measurement

- `loadFont(path)` - Loads TTF/OTF font
- `setHeadlessFont(state, font)` - Injects font for Word.width
- `measureTextWidth(font, text, fontSize)` - Pure text width calculation

### Entity Discovery

- `getEntityNames(state)` - All named entity names (sorted)
- `queryEntities(state, ...componentNames)` - Entity IDs by component
- `hasComponentByName(state, eid, name)` - Check if entity has component by name
- `getComponentData(state, eid, componentName)` - Get component field values
- `getEntityData(state, eid)` - Get all component data for entity

### Sequence Inspection

- `getSequenceInfo(state, name)` - Sequence state by name
- `getAllSequences(state)` - All sequences with state/progress

### Snapshot

- `createSnapshot(state, options?)` - Creates world snapshot
- `formatSnapshot(snapshot)` - Human-readable text format
- `toJSON(snapshot, options?)` - Structured JSON output

SnapshotOptions:
- `entities?: string[]` - Filter by entity names
- `components?: string[]` - Filter by component names
- `sequences?: boolean` - Include sequence state (default: true)
- `project?: boolean` - Include viewport projection (default: true)
- `detail?: 'brief' | 'standard' | 'full'` - Output verbosity (default: 'standard')
- `precision?: number` - Decimal places for floats (default: 2)

ToJSONOptions:
- `compact?: boolean` - Omit indentation

Viewport: `{ x, y, z, visible }` - normalized 0-1, (0,0) top-left.
Hints: `{ type, entity?, message }` - contextual warnings/info.

#### Examples

## Examples

```typescript
import {
  createHeadlessState, loadFont, parseWorldXml, setHeadlessFont,
  getEntityNames, getAllSequences, createSnapshot, toJSON
} from 'vibegame/cli';
import { playSequence, resetSequence } from 'vibegame/tweening';

// Setup
const font = await loadFont('./font.ttf');
const state = createHeadlessState({ plugins: [TransformsPlugin, TweenPlugin, TextPlugin] });
setHeadlessFont(state, font);
parseWorldXml(state, xmlContent);

// Discover entities and sequences
const names = getEntityNames(state);
const sequences = getAllSequences(state);

// Step and snapshot (viewport projection included by default)
state.step(0);
console.log(toJSON(createSnapshot(state, { entities: names })));

// Play sequence, step frames
const seq = state.getEntityByName('intro');
resetSequence(state, seq);
playSequence(state, seq);
for (let i = 0; i < 60; i++) state.step(1/60);

state.dispose();
```

### Input

Focus-aware input for mouse, keyboard, gamepad with buffered actions. Keyboard responds only when canvas focused.

### Components

**InputState**
- moveX/Y/Z: f32 - Movement axes (-1 to 1)
- lookX/Y: f32 - Mouse delta
- scrollDelta: f32 - Wheel delta
- jump, primaryAction, secondaryAction: ui8 (0/1)
- leftMouse, rightMouse, middleMouse: ui8 (0/1)

### Functions
- `setTargetCanvas(canvas)` - Register canvas for focus input
- `consumeJump()` - Consume buffered jump
- `consumePrimary/Secondary()` - Consume buffered actions

#### Examples

```typescript
import { InputState, consumeJump, consumePrimary } from 'vibegame/input';

// Read input in system
const moveX = InputState.moveX[entity];
if (InputState.jump[entity]) { /* jump available */ }

// Consume buffered action (prevents double use)
if (consumeJump()) { velocity.y = JUMP_FORCE; }
if (consumePrimary()) { spawnProjectile(); }
```

### Line

2D billboard line rendering with GPU-accelerated fat lines. Batched rendering for performance.

### Components

**Line**
- offsetX/Y/Z: f32 (1/0/0) - End point offset from entity
- color: ui32 (0xffffff), thickness: f32 (2), opacity: f32 (1)
- visible: ui8 (1)
- arrowStart/End: ui8 (0), arrowSize: f32 (0.2)

#### Examples

```typescript
import { LinePlugin } from 'vibegame/line';
GAME.withPlugin(LinePlugin).run();
```

```xml
<entity transform line="offset: 5 0 0"></entity>
<entity transform line="offset: 3 2 0; color: 0xff0000; arrow-end: 1; arrow-size: 0.3"></entity>
```

### Orbit Camera

Standalone orbital camera with mouse look and scroll zoom for third-person views.

### Components

**OrbitCamera**
- target: eid (0) - Entity to orbit
- inputSource: eid (0) - Entity with InputState
- currentYaw/Pitch/Distance: f32 - Current values
- targetYaw/Pitch/Distance: f32 - Target values
- minDistance/maxDistance: f32 (1/25)
- smoothness: f32 (0.5)
- offsetX/Y/Z: f32 (0/1.25/0)
- sensitivity: f32 (0.007), zoomSensitivity: f32 (1.5)

### Recipe
- `<orbit-camera>` - Camera with auto-setup for target and input

#### Examples

```xml
<!-- Auto-creates target and links to player -->
<orbit-camera></orbit-camera>

<!-- Custom settings -->
<orbit-camera target-distance="10" min-distance="5" max-distance="20" offset-y="2"></orbit-camera>
```

```typescript
// Switch target dynamically
OrbitCamera.target[cameraEntity] = newTargetEntity;
```

### Physics

3D physics with Rapier: rigid bodies, collisions, character controllers. Body position is authoritative (overrides Transform).

### Enums

**BodyType**: Dynamic (0), Fixed (1), KinematicPositionBased (2), KinematicVelocityBased (3)
**ColliderShape**: Box (0), Sphere (1)

### Components

**Body** - Physics body
- type: ui8 (Fixed), mass: f32 (1), gravityScale: f32 (1)
- posX/Y/Z, rotX/Y/Z/W, velX/Y/Z: f32
- eulerX/Y/Z: f32 (degrees shorthand)

**Collider** - Collision shape
- shape: ui8 (Box), sizeX/Y/Z: f32 (1), radius: f32 (0.5)
- friction: f32 (0.5), restitution: f32 (0), isSensor: ui8 (0)

**CharacterController** - Player physics
- grounded: ui8, platform: eid, platformVelX/Y/Z: f32
- offset: f32 (0.08), maxSlope: f32 (45°), snapDist: f32 (0.5)

**CharacterMovement** - Movement input
- desiredVelX/Y/Z, velocityY, actualMoveX/Y/Z: f32

**Force/Impulse** (one-shot, auto-removed)
- ApplyForce, ApplyImpulse, ApplyTorque: x, y, z (f32)
- SetLinearVelocity, KinematicMove: x, y, z (f32)

**Collision Events**
- TouchedEvent: other (eid) - collision started
- TouchEndedEvent: other (eid) - collision ended

### Recipes

- `static-part` - Fixed body (grounds, walls)
- `dynamic-part` - Gravity-affected (balls, crates)
- `kinematic-part` - Script-controlled (platforms)

#### Examples

### XML Usage

```xml
<!-- Static ground -->
<static-part pos="0 -0.5 0" shape="box" size="20 1 20" color="#808080"></static-part>

<!-- Dynamic ball -->
<dynamic-part pos="0 5 0" shape="sphere" size="1" restitution="0.8"></dynamic-part>

<!-- Moving platform -->
<kinematic-part name="lift" pos="0 2 0" shape="box" size="3 0.5 3"></kinematic-part>
<tween target="lift" attr="body.pos-y" from="2" to="5" duration="3"></tween>
```

### TypeScript

```typescript
import { Body, Collider, BodyType, ApplyImpulse, TouchedEvent } from 'vibegame/physics';

// Apply jump impulse
state.addComponent(entity, ApplyImpulse, { x: 0, y: 50, z: 0 });

// Collision detection
const touchedQuery = GAME.defineQuery([TouchedEvent]);
for (const entity of touchedQuery(state.world)) {
  console.log(`${entity} collided with ${TouchedEvent.other[entity]}`);
}

// Character movement
CharacterMovement.desiredVelX[entity] = input.x * 5;
if (CharacterController.grounded[entity]) CharacterMovement.velocityY[entity] = 10;
```

### Player

Player character controller with physics movement, jumping, and platform momentum inheritance.

### Components

**Player**
- speed: f32 (5.3), jumpHeight: f32 (2.3), rotationSpeed: f32 (10)
- canJump, isJumping: ui8
- cameraEntity: eid - Linked camera for orientation
- inheritedVelX/Z: f32 - Platform momentum

### Recipe
- `<player>` - Complete setup with physics, input, respawn

#### Examples

```xml
<!-- Auto-created if omitted, or customize -->
<player pos="0 2 0" speed="8" jump-height="3"></player>
```

**Controls**: WASD/Arrows move, Space jump. Camera via OrbitCameraPlugin.

### Postprocessing

Post-processing effects: bloom, dithering, SMAA, tonemapping. Requires explicit plugin registration.

### Components

**Bloom**
- intensity: f32 (1.0), luminanceThreshold: f32 (1.0)
- mipmapBlur: ui8 (1), radius: f32 (0.85), levels: ui8 (8)

**Dithering**
- colorBits: ui8 (4), intensity: f32 (1.0), grayscale: ui8 (0)
- scale: f32 (1.0), noise: f32 (1.0)

**SMAA** - preset: ui8 (2) - 0=low, 1=medium, 2=high, 3=ultra

**Tonemapping**
- mode: ui8 (7) - 0=linear, 7=aces-filmic, etc.

### Tonemapping Modes
0: linear, 1: reinhard, 4: uncharted2, 7: aces-filmic (default), 8: agx, 9: neutral

#### Examples

```typescript
import { PostprocessingPlugin } from 'vibegame/postprocessing';
GAME.withPlugin(PostprocessingPlugin).run();
```

```xml
<orbit-camera bloom="intensity: 2; luminance-threshold: 0.8"></orbit-camera>
<orbit-camera dithering="color-bits: 3; scale: 2"></orbit-camera>
<orbit-camera bloom="intensity: 1.5" tonemapping="mode: aces-filmic"></orbit-camera>
```

### Rendering

Three.js rendering with instanced meshes, lights, and cameras.

### Components

**Renderer** - Visual mesh
- shape: ui8 (0=box, 1=sphere), sizeX/Y/Z: f32 (1)
- color: ui32 (0xffffff), visible: ui8 (1), unlit: ui8 (0)

**MainCamera**
- projection: ui8 (0=perspective, 1=orthographic)
- fov: f32 (75), orthoSize: f32 (10)

**AmbientLight**
- skyColor: ui32 (0x87ceeb), groundColor: ui32 (0x4a4a4a), intensity: f32 (0.6)

**DirectionalLight**
- color: ui32, intensity: f32 (1), castShadow: ui8 (1)
- directionX/Y/Z: f32, distance: f32 (30)

### Performance
- Instance pooling: starts 1000, doubles when full
- Warning at 10,000 instances, error at 50,000

#### Examples

```xml
<!-- Rendered box -->
<renderer shape="box" color="#ff0000" pos="0 1 0"></renderer>

<!-- Custom lighting -->
<entity
  ambient-light="sky-color: 0xffd4a3; intensity: 0.4"
  directional-light="intensity: 1.5; direction-y: 3"
></entity>

<!-- Unlit (emissive) -->
<renderer shape="sphere" color="#ffff00" unlit="1"></renderer>

<!-- Orthographic camera -->
<camera main-camera="projection: orthographic; ortho-size: 20"></camera>
```

### Respawn

Automatic respawn when entities fall below Y=-100.

### Components

**Respawn**
- posX/Y/Z: f32 - Spawn position
- eulerX/Y/Z: f32 - Spawn rotation (degrees)

#### Examples

```xml
<!-- Player recipe includes respawn automatically -->
<player pos="0 5 0"></player>

<!-- Manual respawn component -->
<entity transform body collider respawn="pos: 0 10 -5"></entity>
```

### Startup

Auto-creates player, camera, and lighting at startup if missing.

### Systems (all group: setup)
- **LightingStartupSystem** - Creates default lighting if none exists
- **CameraStartupSystem** - Creates orbit camera with InputState if none exists
- **PlayerStartupSystem** - Creates player entity if none exists

#### Examples

```xml
<!-- Creating your own prevents auto-creation -->
<player pos="10 2 -5"></player>
<entity ambient-light directional-light></entity>
```

### Text

3D text rendering with troika-three-text. Paragraph/Word hierarchy for layout. Supports headless mode via injectable measurement function (see CLI module).

### Components

#### Paragraph
- gap: f32 (0.2) - Space between words
- align: ui8 (1) - 0=left, 1=center, 2=right
- anchorX/anchorY: ui8 (1) - Text anchor
- damping: f32 (0) - Position smoothing (0=instant)

#### Word
- fontSize, color, letterSpacing, lineHeight
- outlineWidth/Color/Blur/OffsetX/OffsetY/Opacity
- strokeWidth/Color/Opacity, fillOpacity, curveRadius
- width (internal), dirty (internal)

### Systems

- **WordRenderSystem** (draw): Creates troika meshes (skips in headless)
- **WordMeasureSystem** (draw): Measures word width via injectable `measureFn`
- **ParagraphArrangeSystem** (simulation): Positions words in paragraph

### Headless

Use `setMeasureFn(state, fn)` to inject custom measurement. CLI module provides `setHeadlessFont()` for Typr.js-based measurement.

#### Examples

## Examples

```xml
<word text="Hello" font-size="2" color="#ff0000"></word>

<paragraph gap="0.3" align="center">
  <word text="Hello" color="#ff4444"></word>
  <word text="World" color="#44ff44"></word>
</paragraph>
```

### Transforms

3D transforms with position, rotation, scale, and parent-child hierarchies.

### Components

**Transform** - Local space
- posX/Y/Z: f32 (0)
- rotX/Y/Z/W: f32 (W=1) - Quaternion
- eulerX/Y/Z: f32 (0) - Degrees
- scaleX/Y/Z: f32 (1)

**WorldTransform** - Auto-computed from hierarchy (read-only)
- Same properties as Transform

#### Examples

```xml
<!-- Position and rotation -->
<entity transform="pos: 0 5 0; euler: 0 45 0; scale: 1.5"></entity>

<!-- Hierarchy (children relative to parent) -->
<entity transform="euler: 0 45 0">
  <entity transform="pos: 2 0 0"></entity>
</entity>
```

```typescript
// Direct property access
Transform.posX[entity] = 10;
Transform.eulerY[entity] = 45; // Auto-syncs to quaternion

// World position after parent transforms
const worldX = WorldTransform.posX[entity];
```

### Tweening

Animates properties with easing. Tweens auto-destroy on completion. Sequences group tweens with timing. Shakers add presentation effects without changing base values.

### Components

**Tween** - Animation controller (auto-destroyed)
- duration: f32 (1), elapsed: f32, easingIndex: ui8

**TweenValue** - Per-field interpolation
- target: eid, from/to/value: f32

**Sequence** - Animation orchestrator
- state: ui8 (Idle=0, Playing=1), currentIndex, itemCount, pauseRemaining: f32

**Shaker** - Presentation modifier (draw-time only)
- target: eid, value: f32, intensity: f32 (0-1)
- mode: ui8 (Additive=0, Multiplicative=1)

### Shorthand Targets

| Shorthand | Expands To |
|-----------|------------|
| `at` | transform.posX/Y/Z |
| `scale` | transform.scaleX/Y/Z |
| `rotation` | body.eulerX/Y/Z (or transform) |

### Easing Functions
`linear`, `sine-in/out/in-out`, `quad-*`, `cubic-*`, `quart-*`, `expo-*`, `circ-*`, `back-*`, `elastic-*`, `bounce-*`

### Functions

```typescript
createTween(state, entity, target, options): number | null
createShaker(state, entity, target, options): number | null
playSequence(state, entity): void
stopSequence(state, entity): void
resetSequence(state, entity): void
completeSequence(state, entity): void
```

#### Examples

### XML Tweens

```xml
<!-- Single property -->
<kinematic-part name="lift" pos="0 0 0" shape="box" size="4 0.5 4"></kinematic-part>
<tween target="lift" attr="body.pos-y" from="0" to="5" duration="3" easing="sine-in-out"></tween>

<!-- Shorthands -->
<renderer name="cube" shape="box"></renderer>
<tween target="cube" attr="at" to="10 5 0" duration="2"></tween>
<tween target="cube" attr="scale" to="2 2 2" duration="1" easing="back-out"></tween>
```

### Sequences

```xml
<!-- Named sequence (starts paused) -->
<sequence name="bounce">
  <tween target="cube" attr="scale" to="1.3 1.3 1.3" duration="0.15" easing="back-out"></tween>
  <pause duration="0.1"></pause>
  <tween target="cube" attr="scale" to="1 1 1" duration="0.15"></tween>
</sequence>

<!-- Autoplay: tweens before pause run in parallel -->
<sequence autoplay="true">
  <tween target="cube" attr="at" to="0 0 0" duration="1"></tween>
  <tween target="cube" attr="scale" to="1 1 1" duration="0.5"></tween>
  <pause duration="0.3"></pause>
  <tween target="cube" attr="scale" to="1.2 1.2 1.2" duration="0.2"></tween>
</sequence>
```

### TypeScript

```typescript
import { createTween, playSequence, resetSequence } from 'vibegame/tweening';

// Create tween
createTween(state, entity, 'at', { from: [0,0,0], to: [10,5,0], duration: 1.5 });

// Trigger sequence
const seq = state.getEntityByName('bounce');
resetSequence(state, seq);
playSequence(state, seq);
```

### Shakers

```xml
<!-- Multiple effects on same property -->
<shaker name="pulse" target="cube" attr="scale" value="0.8" intensity="0" mode="multiplicative"></shaker>
<tween target="pulse" attr="shaker.intensity" to="1" duration="0.3"></tween>
```

Shakers modify at draw time, base values unchanged. Use `shaker.intensity` to tween effect strength.

### Ui

Web-native HTML/CSS UI overlays with GSAP animations and ECS state sync.

### Functions
- `createUIOverlay(canvas)` - Positioned UI container
- `bindUIToState(uiManager, state)` - Connect UI to ECS

### Patterns
```html
<div id="game-ui" style="position: fixed; pointer-events: none; z-index: 1000;">
  <div class="hud" style="pointer-events: auto;">
    <span id="score">0</span>
  </div>
</div>
```

```typescript
const UISystem = {
  update: (state) => {
    document.getElementById('score').textContent = GameState.score[entity];
  }
};

// GSAP animations
gsap.to("#score", { scale: 1.2, duration: 0.2, yoyo: true, repeat: 1 });
```

#### Examples

```typescript
// Update UI from ECS state
const GameState = GAME.defineComponent({ score: GAME.Types.ui32 });
const UISystem = {
  update: (state) => {
    const query = GAME.defineQuery([GameState]);
    for (const entity of query(state.world)) {
      document.getElementById('score').textContent = GameState.score[entity];
    }
  }
};
```
